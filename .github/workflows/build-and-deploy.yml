name: build-and-deploy-workflow

on:
  workflow_call:
    inputs:
      targetRootDomain:
        required: true
        type: string
      applicationName:
        required: true
        type: string
      containerPort:
        required: true
        type: string
      numberOfApplicationReplicas:
        required: true
        type: number
      pathPattern:
        required: true
        type: string
      needsDatabase:
        required: true
        type: boolean
      sisterApp:
        required: false
        type: string
      angularApp:
        required: false
        type: boolean

jobs:
  kubernetes-deployment:
    runs-on: ubuntu-22.04
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          repository: ByteBlazer/build-and-deploy
          path: "./build-and-deloy-repo"
      - name: GetAllBranchNames
        id: GetAllBranchNames
        run: |
          gitHubBranchesUrl="$(echo '${{github.event.repository.branches_url}}'|sed 's/{\/branch}//g')";
          curl --location --request GET $gitHubBranchesUrl --header 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' -o branches.json
          branches="$(cat branches.json | jq -r '.[].name'|awk '{print $1}' ORS=",")"
          echo "::set-output name=branches::$branches"
      - name: view the secrets  context
        shell: bash
        id: ViewSecretKeys
        run: |
          echo "$SECRETS_CONTEXT">secrets.json
          keyValuePairsJsonString="$(cat secrets.json | awk '{print $0}' ORS="")"
          echo "::set-output name=keyValuePairsJsonString::$keyValuePairsJsonString"
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
      - name: EvaluateParams
        uses: actions/github-script@v6
        id: EvaluateParams
        with:
          result-encoding: string
          script: |
            const script = require('./build-and-deloy-repo/js/script.js');
            return script({ github, context, triggeredBySisterApp:"${{github.event.client_payload.triggeredBySisterApp}}",triggeredByBranchDeleteEvent:"${{github.event.client_payload.triggeredByBranchDeleteEvent}}",humanTriggered:"${{github.event.client_payload.humanTriggered}}",featureBranchName:"${{github.event.client_payload.featureBranchName}}",triggeredBy:"${{github.event.client_payload.triggeredBy}}",phoneNumberLastFiveDigits:"${{github.event.client_payload.phoneNumberLastFiveDigits}}",fastForwardServerMilliseconds:"${{github.event.client_payload.fastForwardServerMilliseconds}}" ,corp:"${{ secrets.CORP }}",nameOfLightweightNamespace:"${{secrets.K8S_LIGHTWEIGHT_NAMESPACE}}",nameOfTestNamespace:"${{ secrets.K8S_TEST_NAMESPACE}}",nameOfProductionNamespace:"${{ secrets.K8S_PRODUCTION_NAMESPACE}}", branches:"${{steps.GetAllBranchNames.outputs.branches}}",keyValuePairsJsonString:'${{steps.ViewSecretKeys.outputs.keyValuePairsJsonString}}',targetRootDomain:'${{inputs.targetRootDomain}}',applicationName:'${{inputs.applicationName}}',containerPort:'${{inputs.containerPort}}',pathPattern:'${{inputs.pathPattern}}',angularApp:'${{inputs.angularApp}}',sisterApp:'${{inputs.sisterApp}}',numberOfApplicationReplicas:'${{inputs.numberOfApplicationReplicas}}',needsDatabase:'${{inputs.needsDatabase}}'});
      - name: TriggerSisterAppDeploymentOrDelete
        id: TriggerSisterAppDeploymentOrDelete
        if: ${{fromJson(steps.EvaluateParams.outputs.result).triggerSisterAppInCaseCorrespondingBranchDoesNOTExist == true}}
        run: |
          curl --location --request GET '${{fromJson(steps.EvaluateParams.outputs.result).githubBranchesApiEndpoint}}' --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o sisterAppBranches.json
          branchExistsInSisterApp="$(cat sisterAppBranches.json | jq -r '.[].name'|awk '{print $1}' | grep '${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}}' | wc -l)"
          if [ $branchExistsInSisterApp == "0" ]
          then
          echo "Triggering request for sisterApp deployment/delete...."
          curl -d '${{fromJson(steps.EvaluateParams.outputs.result).postRequestBodyJSON}}' -H "Accept: application/vnd.github+json" --request POST '${{fromJson(steps.EvaluateParams.outputs.result).githubDispatchApiEndpoint}}' --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o response.json
          cat response.json
          echo "....sisterApp deployment/delete triggered."
          else
          echo "SisterApp was not deployed/deleted as the corresponding branch: ${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}} already exists in the sisterApp"
          fi
      - name: CodeCheckout
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        uses: actions/checkout@v3
        with:
          ref: ${{fromJson(steps.EvaluateParams.outputs.result).branchRefToBeCheckedOut}}
      # - name: MakeFileCopies
      #   run:  cp kubernetes/file.yaml  kubernetes/copy-of-file.yaml
      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          repository: ByteBlazer/build-and-deploy
          path: "./build-and-deloy-repo"
      - name: ReplaceTokensInAngularEnvironmentFiles
        if: ${{fromJson(steps.EvaluateParams.outputs.result).angularApp == 'true'}}
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./src/environments/environment.prod.ts"]'
        env:
          BACKEND_APP_HOST_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          BACKEND_APP_BASE_CONTEXT: ${{fromJson(steps.EvaluateParams.outputs.result).pathPatternWithoutTrailingSlash}}
      - name: DEBUG-ViewAngularEnvFiles
        if: ${{fromJson(steps.EvaluateParams.outputs.result).angularApp == 'true'}}
        run: |
          echo "\n**************************************************************************\n"
          cat src/environments/environment.prod.ts
          echo "\n**************************************************************************\n"
      - name: ConfigureKubectlCommand
        run: |
          echo 'Configuring kubectl command to talk to EKS cluster inside corporate AWS account.......'
          aws eks --region ${{ secrets.AWS_DEFAULT_REGION }} update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }}
          echo '....configuration of kubectl command completed'
          kubectl get pods
      - name: ReplaceTokensInKubernetesDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./build-and-deloy-repo/kubernetes/namespace.yaml","./build-and-deloy-repo/kubernetes/deployment.yaml","./build-and-deloy-repo/kubernetes/service.yaml","./build-and-deloy-repo/kubernetes/ingress.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_DEPLOYMENT_NUMBER_OF_REPLICAS: ${{fromJson(steps.EvaluateParams.outputs.result).numberOfReplicas}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerName}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPort}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceName}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePort}}
          YAML_NUMERIC_HASH_OF_HOST_AND_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHostAndPort}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_PATH_PATTERN: ${{fromJson(steps.EvaluateParams.outputs.result).pathPattern}}
          YAML_DOCKER_IMAGE_NAME_AND_TAG: ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}}
      - name: ReplaceTokensInKubernetesDatabaseDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed ==  'true'}}
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./build-and-deloy-repo/kubernetes/namespace.yaml","./build-and-deloy-repo/kubernetes/storage.yaml","./build-and-deloy-repo/kubernetes/pvc.yaml","./build-and-deloy-repo/kubernetes/deployment-db.yaml","./build-and-deloy-repo/kubernetes/service-db.yaml","./build-and-deloy-repo/kubernetes/ingress-db.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerNameForDatabase}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPortForDatabase}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePortForDatabase}}
          YAML_NUMERIC_HASH_OF_HOST_AND_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHostAndPortForDatabase}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_DB_SCHEMA_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).dbSchemaName}}
          YAML_HASH_BASED_DB_PASSWORD: ${{fromJson(steps.EvaluateParams.outputs.result).hashBasedDBPassword}}
      - name: DEBUG-ViewReplacedK8sYaml
        run: |
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/deployment.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/ingress.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/service.yaml
          echo "\n**************************************************************************\n"
      - name: DEBUG-ViewReplacedK8sYaml For DB
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true'}}
        run: |
          echo "\n********************   FOR DATABASE   ************************************\n"
          cat build-and-deloy-repo/kubernetes/deployment-db.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/service-db.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/pvc.yaml
          echo "\n**************************************************************************\n"
      - name: DockerImageLayerCaching #You can comment out this whole step. It will only disable docker image caching and will not affect anything else
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        uses: satackey/action-docker-layer-caching@v0.0.11
        continue-on-error: true
      - name: BuildAndPushDockerImage
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow ==  false}}
        run: |
          echo "Going to login to Docker Hub....."
          echo "${{ secrets.DOCKER_LOGIN_PASSWORD}}"|docker login --username ${{ secrets.DOCKER_LOGIN_USER}} --password-stdin 
          echo ".......Logged in successfully to Docker  Hub"
          echo "Going to build the docker image......."
          dockerBuildCommandFirstPart="docker build -t ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} . --quiet"
          dockerBuildCommandSecondPart="${{fromJson(steps.EvaluateParams.outputs.result).buildArgsCommandLineArgsForDockerBuild}}"
          dockerBuildCommand=$dockerBuildCommandFirstPart$dockerBuildCommandSecondPart
          echo "Docker Build Final Command:$dockerBuildCommand"
          eval $dockerBuildCommand
          echo ".......docker image built succesfully"
          echo "Going to push the docker image to docker hub......."
          docker push ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} --quiet
          echo ".......image push to docker hub completed succesfully"
      - name: DeployApplicationToKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl apply -f build-and-deloy-repo/kubernetes/namespace.yaml,build-and-deloy-repo/kubernetes/deployment.yaml,build-and-deloy-repo/kubernetes/service.yaml,build-and-deloy-repo/kubernetes/ingress.yaml
      - name: DeployDatabaseToKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl apply -f build-and-deloy-repo/kubernetes/namespace.yaml,build-and-deloy-repo/kubernetes/storage.yaml,build-and-deloy-repo/kubernetes/pvc.yaml,build-and-deloy-repo/kubernetes/deployment-db.yaml,build-and-deloy-repo/kubernetes/service-db.yaml
      - name: DeleteApplicationFromKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == true}}
        run: |
          kubectl delete -f build-and-deloy-repo/kubernetes/deployment.yaml,build-and-deloy-repo/kubernetes/service.yaml,build-and-deloy-repo/kubernetes/ingress.yaml || exit 0
      - name: DeleteDatabaseFromKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == true}}
        run: |
          kubectl delete -f build-and-deloy-repo/kubernetes/pvc.yaml,build-and-deloy-repo/kubernetes/deployment-db.yaml,build-and-deloy-repo/kubernetes/service-db.yaml || exit 0
      - name: RestartApplicationInKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceName}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
      - name: RestartDatabaseInKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}