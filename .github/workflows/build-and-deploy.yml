name: build-and-deploy-workflow

on:
  workflow_call:
    inputs:
      targetRootDomain:
        required: true
        type: string
      applicationName:
        required: true
        type: string
      containerPort:
        required: true
        type: string
      numberOfApplicationReplicas:
        required: true
        type: number
      pathPattern:
        required: true
        type: string
      needsDatabase:
        required: true
        type: boolean
      sisterApp:
        required: false
        type: string
      angularApp:
        required: false
        type: boolean
        default: false
      backendApiContextPath:
        required: false
        type: string

jobs:
  kubernetes-deployment:
    runs-on: ubuntu-22.04
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.ADMIN_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.ADMIN_AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.ADMIN_AWS_DEFAULT_REGION }}
    steps:
      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          repository: ByteBlazer/build-and-deploy
          path: "./build-and-deloy-repo"
      - name: GetAllBranchNames
        id: GetAllBranchNames
        run: |
          gitHubBranchesUrl="$(echo '${{github.event.repository.branches_url}}'|sed 's/{\/branch}//g')";
          curl --location --request GET $gitHubBranchesUrl --header 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' -o branches.json
          branches="$(cat branches.json | jq -r '.[].name'|awk '{print $1}' ORS=",")"
          echo "::set-output name=branches::$branches"
      - name: view the secrets  context
        shell: bash
        id: ViewSecretKeys
        run: |
          echo "$SECRETS_CONTEXT">secrets.json
          keyValuePairsJsonString="$(cat secrets.json | awk '{print $0}' ORS="")"
          echo "::set-output name=keyValuePairsJsonString::$keyValuePairsJsonString"
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
      - name: EvaluateParams
        uses: actions/github-script@v6
        id: EvaluateParams
        with:
          result-encoding: string
          script: |
            const script = require('./build-and-deloy-repo/js/script.js');
            return script({ github, context, triggeredBySisterApp:"${{github.event.client_payload.triggeredBySisterApp}}",triggeredByBranchDeleteEvent:"${{github.event.client_payload.triggeredByBranchDeleteEvent}}",humanTriggered:"${{github.event.client_payload.humanTriggered}}",featureBranchName:"${{github.event.client_payload.featureBranchName}}",triggeredBy:"${{github.event.client_payload.triggeredBy}}",phoneNumberLastFiveDigits:"${{github.event.client_payload.phoneNumberLastFiveDigits}}",fastForwardServerMilliseconds:"${{github.event.client_payload.fastForwardServerMilliseconds}}" ,corp:"${{ secrets.CORP }}",nameOfLightweightNamespace:"${{secrets.K8S_LIGHTWEIGHT_NAMESPACE}}",nameOfTestNamespace:"${{ secrets.K8S_TEST_NAMESPACE}}",nameOfProductionNamespace:"${{ secrets.K8S_PRODUCTION_NAMESPACE}}", branches:"${{steps.GetAllBranchNames.outputs.branches}}",keyValuePairsJsonString:'${{steps.ViewSecretKeys.outputs.keyValuePairsJsonString}}',targetRootDomain:'${{inputs.targetRootDomain}}',applicationName:'${{inputs.applicationName}}',containerPort:'${{inputs.containerPort}}',pathPattern:'${{inputs.pathPattern}}',angularApp:'${{inputs.angularApp}}',backendApiContextPath:'${{inputs.backendApiContextPath}}',sisterApp:'${{inputs.sisterApp}}',numberOfApplicationReplicas:'${{inputs.numberOfApplicationReplicas}}',needsDatabase:'${{inputs.needsDatabase}}'});
      - name: GetLastCommitInfo
        id: GetLastCommitInfo
        run: |
          curl --location --request GET '${{fromJson(steps.EvaluateParams.outputs.result).githubBranchesApiEndpoint}}' --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o appBranches.json
          lastCommitUrl="$(cat appBranches.json | jq -r '.[] | select(.name=="${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}}") | .commit.url')"  
          curl --location --request GET $lastCommitUrl --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o commitInfo.json
          commitMessage="$(cat commitInfo.json|jq -r .commit.message)"
          commitDate="$(cat commitInfo.json|jq -r .commit.committer.date)"
          committerName="$(cat commitInfo.json|jq -r .commit.committer.name)"
          committerLogin="$(cat commitInfo.json|jq -r .committer.login)"
          originalCommitDate="$(cat commitInfo.json|jq -r .commit.author.date)"
          originalCommitterName="$(cat commitInfo.json|jq -r .commit.author.name)"
          originalCommitterLogin="$(cat commitInfo.json|jq -r .author.login)"
          commitUrl="$(cat commitInfo.json|jq -r .html_url)"
          commitFiles="$(cat commitInfo.json|jq -r .files[].filename | awk '{print $1}' ORS=',')"
          releaseDbSqlScriptsModified="$(cat commitInfo.json|jq -r .files[].filename | grep release-db-scripts.sql | wc -l)"
          echo "::set-output name=commitMessage::$commitMessage"
          echo "::set-output name=commitDate::$commitDate"
          echo "::set-output name=committerName::$committerName"
          echo "::set-output name=committerLogin::$committerLogin"
          echo "::set-output name=originalCommitDate::$originalCommitDate"
          echo "::set-output name=originalCommitterName::$originalCommitterName"
          echo "::set-output name=originalCommitterLogin::$originalCommitterLogin"
          echo "::set-output name=commitUrl::$commitUrl"
          echo "::set-output name=commitFiles::$commitFiles"
          echo "::set-output name=releaseDbSqlScriptsModified::$releaseDbSqlScriptsModified"
      - name: SendBeginningSlackNotification
        id: SendBeginningSlackNotification
        if: ${{ always() }}
        run: |
          content="****************************************************************\n\
          Build triggered for the application *XXXXX*. Front end URL will be: https://XXXXX\n\
          Commit Message: XXXXX\n\
          Triggering Commit: xxxxx XXXXX at XXXXX\n\
          Original Commit: xxxxx xxxxx at xxxxx\n\
          Commit Details (Only accessible if you are a collaborator in GitHub): xxxx \n\
          Starting status as of now: *${{job.status}}*. Expect another update in around 5-10 minutes...\n\
          ****************************************************************"
          messageJson={\""text\"":\""$content\""}
          curl -d "$messageJson" --request POST '${{secrets.SLACK_WEBHOOK_URL}}'
      - name: TriggerSisterAppDeploymentOrDelete
        id: TriggerSisterAppDeploymentOrDelete
        if: ${{fromJson(steps.EvaluateParams.outputs.result).triggerSisterAppInCaseCorrespondingBranchDoesNOTExist == true}}
        run: |
          curl --location --request GET '${{fromJson(steps.EvaluateParams.outputs.result).githubBranchesApiForSisterAppEndpoint}}' --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o sisterAppBranches.json
          branchExistsInSisterApp="$(cat sisterAppBranches.json | jq -r '.[].name'|awk '{print $1}' | grep '${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}}' | wc -l)"
          if [ $branchExistsInSisterApp == "0" ]
          then
          echo "Triggering request for sisterApp deployment/delete...."
          curl -d '${{fromJson(steps.EvaluateParams.outputs.result).postRequestBodyJSON}}' -H "Accept: application/vnd.github+json" --request POST '${{fromJson(steps.EvaluateParams.outputs.result).githubDispatchApiEndpoint}}' --header 'Authorization: token ${{ secrets.PERSONAL_GITHUB_TOKEN }}' -o response.json
          cat response.json
          echo "....sisterApp deployment/delete triggered."
          else
          echo "SisterApp was not deployed/deleted as the corresponding branch: ${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}} already exists in the sisterApp"
          fi
      - name: CodeCheckout
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        uses: actions/checkout@v3
        with:
          ref: ${{fromJson(steps.EvaluateParams.outputs.result).branchRefToBeCheckedOut}}
      # - name: MakeFileCopies
      #   run:  cp kubernetes/file.yaml  kubernetes/copy-of-file.yaml
      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          repository: ByteBlazer/build-and-deploy
          path: "./build-and-deloy-repo"
      - name: ReplaceTokensInAngularEnvironmentFiles
        if: ${{fromJson(steps.EvaluateParams.outputs.result).angularApp == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./src/environments/environment.prod.ts"]'
        env:
          BACKEND_APP_HOST_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          BACKEND_APP_BASE_CONTEXT: ${{fromJson(steps.EvaluateParams.outputs.result).backendApiContextPath}}
      - name: DEBUG-ViewAngularEnvFiles
        if: ${{fromJson(steps.EvaluateParams.outputs.result).angularApp == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          echo "\n**************************************************************************\n"
          cat src/environments/environment.prod.ts
          echo "\n**************************************************************************\n"
      - name: ConfigureKubectlCommand
        run: |
          echo 'Configuring kubectl command to talk to EKS cluster inside corporate AWS account.......'
          aws eks --region ${{ secrets.ADMIN_AWS_DEFAULT_REGION }} update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }}
          echo '....configuration of kubectl command completed'
          kubectl get pods
      - name: ReplaceTokensInKubernetesDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./build-and-deloy-repo/kubernetes/namespace.yaml","./build-and-deloy-repo/kubernetes/deployment.yaml","./build-and-deloy-repo/kubernetes/service.yaml","./build-and-deloy-repo/kubernetes/ingress.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_DEPLOYMENT_NUMBER_OF_REPLICAS: ${{fromJson(steps.EvaluateParams.outputs.result).numberOfReplicas}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerName}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPort}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceName}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePort}}
          YAML_NUMERIC_HASH_OF_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHost}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_PATH_PATTERN: ${{fromJson(steps.EvaluateParams.outputs.result).pathPattern}}
          YAML_DOCKER_IMAGE_NAME_AND_TAG: ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}}
      - name: ReplaceTokensInKubernetesDatabaseDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed ==  'true'}}
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./build-and-deloy-repo/kubernetes/namespace.yaml","./build-and-deloy-repo/kubernetes/storage.yaml","./build-and-deloy-repo/kubernetes/pvc.yaml","./build-and-deloy-repo/kubernetes/deployment-db.yaml","./build-and-deloy-repo/kubernetes/service-db.yaml","./build-and-deloy-repo/kubernetes/ingress-db.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerNameForDatabase}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPortForDatabase}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePortForDatabase}}
          YAML_NUMERIC_HASH_OF_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHost}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_DB_SCHEMA_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).dbSchemaName}}
          YAML_HASH_BASED_DB_PASSWORD: ${{fromJson(steps.EvaluateParams.outputs.result).hashBasedDBPassword}}
      - name: ReplaceTokensInBuildInfoJsonFile
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./build-and-deloy-repo/buildinfo.json"]'
        env:
          JSON_BUILDINFO_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          JSON_BUILDINFO_BRANCH_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).branchNameToBeCheckedOut}}
          JSON_BUILDINFO_BUILD_TIME: ${{fromJson(steps.EvaluateParams.outputs.result).deployTimestamp}}
          JSON_BUILDINFO_LAST_COMMIT_MSG: ${{steps.GetLastCommitInfo.outputs.commitMessage}}
          JSON_BUILDINFO_LAST_COMMIT_DATE: ${{steps.GetLastCommitInfo.outputs.commitDate}}
          JSON_BUILDINFO_LAST_COMMITTER_NAME: ${{steps.GetLastCommitInfo.outputs.committerName}}
          JSON_BUILDINFO_LAST_COMMITTER_LOGIN: ${{steps.GetLastCommitInfo.outputs.committerLogin}}
          JSON_BUILDINFO_ORIGINAL_COMMIT_DATE: ${{steps.GetLastCommitInfo.outputs.originalCommitDate}}
          JSON_BUILDINFO_ORIGINAL_COMMITTER_NAME: ${{steps.GetLastCommitInfo.outputs.originalCommitterName}}
          JSON_BUILDINFO_ORIGINAL_COMMITTER_LOGIN: ${{steps.GetLastCommitInfo.outputs.originalCommitterLogin}}
          JSON_BUILDINFO_LAST_COMMIT_URL: ${{steps.GetLastCommitInfo.outputs.commitUrl}}
          JSON_BUILDINFO_LAST_COMMIT_FILES: ${{steps.GetLastCommitInfo.outputs.commitFiles}}
          JSON_BUILDINFO_RELEASE_SQL_SCRIPTS_MODIFIED: ${{steps.GetLastCommitInfo.outputs.releaseDbSqlScriptsModified}}
      - name: CopyBuildInfoJsonToSourceRoot
        run: |
          cp ./build-and-deloy-repo/buildinfo.json .
          echo "***********   BUILD INFO JSON   *******************"
          cat buildinfo.json
          echo "***********   BUILD INFO JSON   *******************"
      - name: DEBUG-ViewReplacedK8sYaml
        run: |
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/deployment.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/ingress.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/service.yaml
          echo "\n**************************************************************************\n"
      - name: DEBUG-ViewReplacedK8sYaml For DB
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true'}}
        run: |
          echo "\n********************   FOR DATABASE   ************************************\n"
          cat build-and-deloy-repo/kubernetes/deployment-db.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/service-db.yaml
          echo "\n**************************************************************************\n"
          cat build-and-deloy-repo/kubernetes/pvc.yaml
          echo "\n**************************************************************************\n"
      # - name: DockerImageLayerCaching #You can comment out this whole step. It will only disable docker image caching and will not affect anything else
      #   if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
      #   uses: satackey/action-docker-layer-caching@v0.0.11
      #   continue-on-error: true
      - name: BuildAndPushDockerImage
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow ==  false}}
        run: |
          echo "Going to login to Docker Hub....."
          echo "${{ secrets.DOCKER_LOGIN_PASSWORD}}"|docker login --username ${{ secrets.DOCKER_LOGIN_USER}} --password-stdin 
          echo ".......Logged in successfully to Docker  Hub"
          echo "Going to build the docker image......."
          dockerBuildCommandFirstPart="docker build -t ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} --build-arg APP_ENV=${{fromJson(steps.EvaluateParams.outputs.result).env}}  . --quiet"
          dockerBuildCommandSecondPart="${{fromJson(steps.EvaluateParams.outputs.result).buildArgsCommandLineArgsForDockerBuild}}"
          dockerBuildCommand=$dockerBuildCommandFirstPart$dockerBuildCommandSecondPart
          echo "Docker Build Final Command:$dockerBuildCommand"
          eval $dockerBuildCommand
          echo ".......docker image built succesfully"
          echo "Going to push the docker image to docker hub......."
          docker push ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} --quiet
          echo ".......image push to docker hub completed succesfully"
      - name: DeployApplicationToKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl apply -f build-and-deloy-repo/kubernetes/namespace.yaml,build-and-deloy-repo/kubernetes/deployment.yaml,build-and-deloy-repo/kubernetes/service.yaml,build-and-deloy-repo/kubernetes/ingress.yaml
      - name: DeployDatabaseToKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl apply -f build-and-deloy-repo/kubernetes/namespace.yaml,build-and-deloy-repo/kubernetes/storage.yaml,build-and-deloy-repo/kubernetes/pvc.yaml,build-and-deloy-repo/kubernetes/deployment-db.yaml,build-and-deloy-repo/kubernetes/service-db.yaml
      - name: DeleteApplicationFromKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == true}}
        run: |
          kubectl delete -f build-and-deloy-repo/kubernetes/deployment.yaml,build-and-deloy-repo/kubernetes/service.yaml,build-and-deloy-repo/kubernetes/ingress.yaml || exit 0
      - name: DeleteDatabaseFromKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == true}}
        run: |
          kubectl delete -f build-and-deloy-repo/kubernetes/pvc.yaml,build-and-deloy-repo/kubernetes/deployment-db.yaml,build-and-deloy-repo/kubernetes/service-db.yaml || exit 0
      - name: RestartApplicationInKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceName}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
      - name: RestartDatabaseInKubernetes
        if: ${{fromJson(steps.EvaluateParams.outputs.result).dbPodNeedsToBeDeployed == 'true' && fromJson(steps.EvaluateParams.outputs.result).deleteFlow == false}}
        run: |
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}