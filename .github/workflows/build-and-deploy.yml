name: build-and-deploy-workflow

on:
  workflow_call:
    inputs:
      rootDomain:
        required: true
        type: string
      application-name:
        required: true
        type: string
      application-container-port:
        required: true
        type: string
      numberOfApplicationReplicas:
        required: true
        type: number
      path-pattern:
        required: true
        type: string
      needsDatabaseInstallation:
        required: true
        type: boolean

jobs:
  kubernetes-deployment:
    runs-on: ubuntu-22.04
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - name: GetAllBranchNames
        id: GetAllBranchNames
        run: |
          gitHubBranchesUrl="$(echo '${{github.event.repository.branches_url}}'|sed 's/{\/branch}//g')";
          curl --location --request GET $gitHubBranchesUrl --header 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' -o branches.json
          branches="$(cat branches.json | jq -r '.[].name'|awk '{print $1}' ORS=",")"
          echo "::set-output name=branches::$branches"
      - name: view the secrets  context
        shell: bash
        id: ViewSecretKeys
        #secretKeys="$(cat secretKeys.json | jq -r '.|keys[]' | awk '{print $1}' ORS=",")"
        run: |
          echo "$SECRETS_CONTEXT">secrets.json
          keyValuePairsJsonString="$(cat secrets.json | awk '{print $0}' ORS="")"
          echo "::set-output name=keyValuePairsJsonString::$keyValuePairsJsonString"
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
      - name: EvaluateParams
        uses: actions/github-script@v6
        id: EvaluateParams
        with:
          result-encoding: string
          script: |
            
            //Lifted from Google. Don't bother how it works. Just hashes a string and return a positive number less than 1000.
            const hash = (str) => {
              let arr = str.split('');
              let result = arr.reduce(
                (hashCode, currentVal) =>
                  (hashCode =
                    currentVal.charCodeAt(0) +
                    (hashCode << 6) +
                    (hashCode << 16) -
                    hashCode),
                0,
              );
              return Math.abs(result);
            };

            //Incoming variables
            const triggeredByAnotherApp =
              '${{github.event.client_payload.triggeredByAnotherApp}}';
            const humanTriggered = '${{github.event.client_payload.humanTriggered}}';
            const featureBranchName = '${{github.event.client_payload.featureBranchName}}';
            const triggeredBy = '${{github.event.client_payload.triggeredBy}}';
            const phoneNumberLastFiveDigits =
              '${{github.event.client_payload.phoneNumberLastFiveDigits}}';
            const fastForwardServerMilliseconds = //TODO: For future dating of servers, needs to be implemented
              '${{github.event.client_payload.fastForwardServerMilliseconds}}';
            const corp = '${{ secrets.CORP }}';
            const nameOfLightweightNamespace = '${{ secrets.K8S_LIGHTWEIGHT_NAMESPACE}}';
            const nameOfTestNamespace = '${{ secrets.K8S_TEST_NAMESPACE}}';
            const nameOfProductionNamespace = '${{ secrets.K8S_PRODUCTION_NAMESPACE}}';
            const dockerEnvVarPrefix = 'DOCKER_ENV_VAR'

            

            let targetRootDomain = '${{inputs.rootDomain}}'; 
            let applicationName = '${{inputs.application-name}}';
            let containerPort = '${{inputs.application-container-port}}';
            let pathPattern = '${{inputs.path-pattern}}';
            let numberOfReplicas = ${{inputs.numberOfApplicationReplicas}};
            let dbPodNeedsToBeDeployed = ${{inputs.needsDatabaseInstallation}}; //TODO: Use this in kubectl command db part. If release and prod,then no. If angular,then no. 

            let applicationBaseName = applicationName.split('-')[0];
            let applicationPostFix = applicationName.split('-')[1];
            if(!applicationBaseName || !applicationPostFix){
              throw new Error("The application should have a base name, a hyphen, and a postfix. E.g. myapp-api or myapp-ui");
            }
            
            let dbSchemaName = applicationBaseName;
            let applicationNameForDatabase = applicationBaseName + '-' + 'db';
            
            let containerPortForDatabase = '3306'; //TODO: Make this dynamic
            let servicePort = '80'; //TODO: Make this dynamic
            let servicePortForDatabase = '3306'; //TODO: Make this dynamic

            let branchRefToBeCheckedOut = 'NA';
            let namespace = 'NA';
            let deploymentName = 'NA';
            let deploymentNameForDatabase = 'NA';
            let groupName = 'NA';
            let containerName = 'NA';
            let containerNameForDatabase = 'NA';
            let serviceName = 'NA';
            let serviceNameForDatabase = 'NA';
            let numericHashOfHostAndPort = 'NA';
            let numericHashOfHostAndPortForDatabase = 'NA';
            let hashBasedDBPassword = 'NA';
            let ingressLbName = 'NA';
            let hostName = 'NA';
            let dockerImageNameAndTag = 'NA';
            let env = 'NA';

            const dockerPhraseForCommonEnvVariables = 'COMMON';
            const envNameForProduction = 'PROD';
            const envNameForTest = 'TEST';
            const envNameForLightWeight = 'LIGHTWEIGHT';

            const dockerEnvBaseVarKeyNameForDBHost = 'DB_HOST';
            const dockerEnvBaseVarKeyNameForDBUserame = 'DB_USERNAME';
            const dockerEnvBaseVarKeyNameForDBPassword = 'DB_PASSWORD';
            const baseVarKeyNameForDBShowSql = 'DB_SHOWSQL';
            const baseVarKeyNameForDBSchema = 'DB_SCHEMA'


            containerName = applicationName;
            containerNameForDatabase = applicationNameForDatabase;

            if (context.eventName == 'repository_dispatch') {
              console.log('This run is because of a respository_dispatch event');

              namespace = nameOfLightweightNamespace;
              numberOfReplicas = 1;

              if (
                //Any one should be true at a time, other should be false. If not, error out.
                (triggeredByAnotherApp == 'true' && humanTriggered == 'true') ||
                (triggeredByAnotherApp == 'false' && humanTriggered == 'false')
              ) {
                throw new Error(
                  'Among triggeredByAnotherApp and humanTriggered, any ONE HAS to be true, and the other SHOULD be false.',
                );
              }

              if (triggeredByAnotherApp == 'true') {
                console.log(
                  'This run is triggered because of another applications feature branch creation process. For e.g. if a feature branch is cut from myapp-ui, then myapp-api also needs to be deployed in order to complete the stack.',
                );

                if (!featureBranchName) {
                  throw new Error(
                    'If triggeredByAnotherApp, featureBranchName needs to be sent.',
                  );
                } else {
                  console.log(
                    'Triggered with Feature branch name as: ' + featureBranchName,
                  );
                  console.log(
                    'Branches from GitHub are:${{steps.GetAllBranchNames.outputs.branches}}',
                  );
                  const branchArray = '${{steps.GetAllBranchNames.outputs.branches}}'.split(
                    ',',
                  );
                  const matchedBranch = branchArray.find(
                    (branch) => branch == 'feature/' + featureBranchName,
                  );
                  if (matchedBranch) {
                    console.log('Feature branch Exists: ' + matchedBranch);
                    branchRefToBeCheckedOut = context.ref;
                    console.log(
                      'Setting branchRefToBeCheckedOut to:' + branchRefToBeCheckedOut,
                    );
                  } else {
                    console.log(
                      'Feature branch DOES NOT Exist. Going to use the code from release branch for deployment.',
                    );
                    branchRefToBeCheckedOut = 'refs/heads/release';
                    console.log(
                      'Setting branchRefToBeCheckedOut to:' + branchRefToBeCheckedOut,
                    );
                  }
                  groupName = featureBranchName;
                  env = envNameForLightWeight;
                  hostName = featureBranchName + '.' + targetRootDomain;

                  serviceName = applicationName + '-' + featureBranchName;
                  serviceNameForDatabase =
                    applicationNameForDatabase + '-' + featureBranchName;

                  dockerImageNameAndTag =
                    corp + '/' + applicationName + ':' + featureBranchName;
                }
              }

              if (humanTriggered == 'true') {
                console.log(
                  'This run has been triggered manually by a user. Going to use the code from release branch for deployment.',
                );
                if (!triggeredBy || !phoneNumberLastFiveDigits) {
                  throw new Error(
                    'The properties:- triggeredBy and phoneNumberLastFiveDigits must be set',
                  );
                }
                groupName = triggeredBy + '-' + phoneNumberLastFiveDigits;
                env = envNameForLightWeight;

                dockerImageNameAndTag =
                  corp +
                  '/' +
                  applicationName +
                  ':' +
                  triggeredBy +
                  '-' +
                  phoneNumberLastFiveDigits;
                hostName =
                  triggeredBy + '-' + phoneNumberLastFiveDigits + '.' + targetRootDomain;
                serviceName =
                  applicationName + '-' + triggeredBy + '-' + phoneNumberLastFiveDigits;
                serviceNameForDatabase =
                  applicationNameForDatabase +
                  '-' +
                  triggeredBy +
                  '-' +
                  phoneNumberLastFiveDigits;
                branchRefToBeCheckedOut = 'refs/heads/release';
                console.log(
                  'Setting branchRefToBeCheckedOut to:' + branchRefToBeCheckedOut,
                );
              }
            } else {
              console.log(
                'This run is an automated run which got triggered either because of a branch create, or a code commit. Will use the code from incoming branch itself.',
              );

              branchRefToBeCheckedOut = context.ref;
              console.log('Setting branchRefToBeCheckedOut to:' + branchRefToBeCheckedOut);

              if (context.ref == 'refs/heads/main') {
                console.log('The current branch is: main');
                groupName = applicationName;
                env = envNameForProduction;
                serviceName = applicationName;
                serviceNameForDatabase = applicationNameForDatabase;
                namespace = nameOfProductionNamespace;
                hostName = targetRootDomain;
                dockerImageNameAndTag = corp + '/' + applicationName;
                numberOfReplicas = numberOfReplicas;
              }
              if (context.ref == 'refs/heads/release') {
                console.log('The current branch is: release');
                groupName = applicationName;
                env = envNameForTest;
                serviceName = applicationName;
                serviceNameForDatabase = applicationNameForDatabase;
                namespace = nameOfTestNamespace;
                hostName = 'test' + '.' + targetRootDomain;
                dockerImageNameAndTag = corp + '/' + applicationName + ':' + 'test';
                numberOfReplicas = numberOfReplicas;
              }
              if (context.ref.startsWith('refs/heads/feature/')) {
                
                featureBranchNameExcludingPrefix = context.ref.split(
                  'refs/heads/feature/',
                )[1];
                console.log(
                  'The current branch is a feature branch. The prefix is feature/ and the name is:' +
                    featureBranchNameExcludingPrefix,
                );
                groupName = featureBranchNameExcludingPrefix;
                env = envNameForLightWeight;

                serviceName = applicationName + '-' + featureBranchNameExcludingPrefix;
                serviceNameForDatabase =
                  applicationNameForDatabase + '-' + featureBranchNameExcludingPrefix;

                hostName = featureBranchNameExcludingPrefix + '.' + targetRootDomain;
                namespace = nameOfLightweightNamespace;
                dockerImageNameAndTag =
                  corp + '/' + applicationName + ':' + featureBranchNameExcludingPrefix;
                numberOfReplicas = 1;

                console.log(
                  'Triggering the other applications also in the stack, so that the deployment can work as a whole unit independently',
                );
              }
            }

            numericHashOfHostAndPort = hash(hostName + containerPort) % 1000; //Less than 1000
            numericHashOfHostAndPortForDatabase =
              hash(hostName + containerPortForDatabase) % 1000; //Less than 1000

            deploymentName = applicationName + '-' + groupName;
            deploymentNameForDatabase = applicationNameForDatabase + '-' + groupName;

            ingressLbName = 'ingress-lb' + '-' + namespace;
            hashBasedDBPassword = hash(hostName) % 100000; //5 digit

            console.log('The list of secret keys ' + '${{steps.ViewSecretKeys.outputs.keyValuePairsJsonString}}');
            const keyValuePairsJsonObj = JSON.parse('${{steps.ViewSecretKeys.outputs.keyValuePairsJsonString}}');
            
            const envKeyPairsForDockerBuild = [];

            for(key in keyValuePairsJsonObj){
              if(key.startsWith(dockerEnvVarPrefix+'_'+env)){
                const value = keyValuePairsJsonObj[key];
                const strippedKey = key.replace(dockerEnvVarPrefix+'_'+env+'_','');
                envKeyPairsForDockerBuild.push({key:strippedKey,value:value});
              }
              if(key.startsWith(dockerEnvVarPrefix+'_'+dockerPhraseForCommonEnvVariables)){
                const value = keyValuePairsJsonObj[key];
                const strippedKey = key.replace(dockerEnvVarPrefix+'_'+dockerPhraseForCommonEnvVariables+'_','');
                envKeyPairsForDockerBuild.push({key:strippedKey,value:value});
              }
            }

            
            if(env == envNameForLightWeight){
                envKeyPairsForDockerBuild.push({key: dockerEnvBaseVarKeyNameForDBHost ,value:"########"});
                envKeyPairsForDockerBuild.push({key: dockerEnvBaseVarKeyNameForDBUsername ,value:"########"});
                envKeyPairsForDockerBuild.push({key: dockerEnvBaseVarKeyNameForDBPassword ,value:hashBasedDBPassword});
                envKeyPairsForDockerBuild.push({key: baseVarKeyNameForDBShowSql ,value:true});
                baseVarKeyNameForDBShowSql
            }else{
                envKeyPairsForDockerBuild.push({key: baseVarKeyNameForDBShowSql ,value:false});
            }

            envKeyPairsForDockerBuild.push({key: baseVarKeyNameForDBSchema ,value:dbSchemaName});

            console.log('Length of Docker env variables list to be applied to docker build:'+envKeyPairsForDockerBuild.length);

            let buildArgsCommandLineArgsForDockerBuild = '';

            for(element of envKeyPairsForDockerBuild){
              console.log(element);
              const {key,value} = element;
              buildArgsCommandLineArgsForDockerBuild = buildArgsCommandLineArgsForDockerBuild + ' --build-arg ' + ' '+key+'='+value;
            }

            console.log('Build args segment for Docker build command:'+buildArgsCommandLineArgsForDockerBuild);
            

            const resultObj = {
              branchRefToBeCheckedOut,
              namespace,
              deploymentName,
              deploymentNameForDatabase,
              numberOfReplicas,
              containerName,
              containerNameForDatabase,
              containerPort,
              containerPortForDatabase,
              serviceName,
              serviceNameForDatabase,
              servicePort,
              servicePortForDatabase,
              numericHashOfHostAndPort,
              numericHashOfHostAndPortForDatabase,
              ingressLbName,
              hostName,
              pathPattern,
              dockerImageNameAndTag,
              dbSchemaName,
              hashBasedDBPassword,
              buildArgsCommandLineArgsForDockerBuild
            };

            console.log('Result Object:' + JSON.stringify(resultObj));

            return JSON.stringify(resultObj);

      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          ref: ${{fromJson(steps.EvaluateParams.outputs.result).branchRefToBeCheckedOut}}
      - name: CodeCheckout
        uses: actions/checkout@v3
        with:
          repository: ByteBlazer/build-and-deploy
          path: './yamls'
     # - name: MakeFileCopies 
     #   run:  cp kubernetes/file.yaml  kubernetes/copy-of-file.yaml
      - name: ConfigureKubectlCommand
        run: |
          echo 'Configuring kubectl command to talk to EKS cluster inside corporate AWS account.......'
          aws eks --region ${{ secrets.AWS_DEFAULT_REGION }} update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }}
          echo '....configuration of kubectl command completed'
          kubectl get pods
      - name: ReplaceTokensInKubernetesDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./yamls/kubernetes/namespace.yaml","./yamls/kubernetes/deployment.yaml","./yamls/kubernetes/service.yaml","./yamls/kubernetes/ingress.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_DEPLOYMENT_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).deploymentName}}
          YAML_DEPLOYMENT_NUMBER_OF_REPLICAS: ${{fromJson(steps.EvaluateParams.outputs.result).numberOfReplicas}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerName}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPort}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceName}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePort}}
          YAML_NUMERIC_HASH_OF_HOST_AND_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHostAndPort}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_PATH_PATTERN: ${{fromJson(steps.EvaluateParams.outputs.result).pathPattern}}
          YAML_DOCKER_IMAGE_NAME_AND_TAG: ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}}
      - name: ReplaceTokensInKubernetesDatabaseDeploymentFiles
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: "<<"
          tokenSuffix: ">>"
          files: '["./yamls/kubernetes/namespace.yaml","./yamls/kubernetes/storage.yaml","./yamls/kubernetes/deployment-db.yaml","./yamls/kubernetes/service-db.yaml","./yamls/kubernetes/ingress-db.yaml"]'
        env:
          YAML_NAMESPACE: ${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          YAML_DEPLOYMENT_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).deploymentNameForDatabase}}
          YAML_CONTAINER_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).containerNameForDatabase}}
          YAML_CONTAINER_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).containerPortForDatabase}}
          YAML_SERVICE_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}}
          YAML_SERVICE_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).servicePortForDatabase}}
          YAML_NUMERIC_HASH_OF_HOST_AND_PORT: ${{fromJson(steps.EvaluateParams.outputs.result).numericHashOfHostAndPortForDatabase}}
          YAML_INGRESS_LB_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).ingressLbName}}
          YAML_HOST: ${{fromJson(steps.EvaluateParams.outputs.result).hostName}}
          YAML_DB_SCHEMA_NAME: ${{fromJson(steps.EvaluateParams.outputs.result).dbSchemaName}}
          YAML_HASH_BASED_DB_PASSWORD: ${{fromJson(steps.EvaluateParams.outputs.result).hashBasedDBPassword}}
      - name: DEBUG-ViewReplacedK8sYaml
        run: |
          echo "**************************************************************************"
          cat yamls/kubernetes/deployment.yaml
          echo "**************************************************************************"
          cat yamls/kubernetes/deployment-db.yaml
          echo "**************************************************************************"
          cat yamls/kubernetes/ingress.yaml
          echo "**************************************************************************"
          cat yamls/kubernetes/service.yaml
          echo "**************************************************************************"
          cat yamls/kubernetes/service-db.yaml
          echo "**************************************************************************"
      - name: DockerImageLayerCaching #You can comment out this whole step. It will only disable docker image caching and will not affect anything else
        uses: satackey/action-docker-layer-caching@v0.0.11
        continue-on-error: true
      - name: BuildAndPushDockerImage
        run: |
          echo "Going to login to Docker Hub....."
          echo "${{ secrets.DOCKER_LOGIN_PASSWORD}}"|docker login --username ${{ secrets.DOCKER_LOGIN_USER}} --password-stdin 
          echo ".......Logged in successfully to Docker  Hub"
          echo "Going to build the docker image......."
          dockerBuildCommandFirstPart="docker build -t ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} . --quiet"
          dockerBuildCommandSecondPart="${{fromJson(steps.EvaluateParams.outputs.result).buildArgsCommandLineArgsForDockerBuild}}"
          dockerBuildCommand=$dockerBuildCommandFirstPart$dockerBuildCommandSecondPart
          echo "Docker Build Final Command:$dockerBuildCommand"
          eval $dockerBuildCommand
          echo ".......docker image built succesfully"
          echo "Going to push the docker image to docker hub......."
          docker push ${{fromJson(steps.EvaluateParams.outputs.result).dockerImageNameAndTag}} --quiet
          echo ".......image push to docker hub completed succesfully"
      - name: DeployToKubernetes
        run: |
          kubectl apply -f yamls/kubernetes/namespace.yaml,yamls/kubernetes/deployment.yaml,yamls/kubernetes/service.yaml,yamls/kubernetes/ingress.yaml
          kubectl apply -f yamls/kubernetes/namespace.yaml,yamls/kubernetes/storage.yaml,yamls/kubernetes/deployment-db.yaml,yamls/kubernetes/service-db.yaml
          kubectl apply -f yamls/kubernetes/deployment.yaml
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceName}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}
          kubectl rollout restart deployment/${{fromJson(steps.EvaluateParams.outputs.result).serviceNameForDatabase}} --namespace=${{fromJson(steps.EvaluateParams.outputs.result).namespace}}    
      